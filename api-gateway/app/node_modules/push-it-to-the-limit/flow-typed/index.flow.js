/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.19.0
 */

declare module "push-it-to-the-limit" {
  declare export * from "push-it-to-the-limit/target/es6";
}

declare module "push-it-to-the-limit/target/es5" {
  declare export * from "push-it-to-the-limit/target/es5/interface";

  declare export * from "push-it-to-the-limit/target/es5/common";

  declare export {
    DEFAULT_DELAY,
    REJECTED,
    REJECTED_ON_CANCEL,
  } from "push-it-to-the-limit/target/es5/common";

  declare export { Limiter } from "push-it-to-the-limit/target/es5/limiter";

  declare export { debounce } from "push-it-to-the-limit/target/es5/wrappers/debounce";

  declare export { delay } from "push-it-to-the-limit/target/es5/wrappers/delay";

  declare export { ratelimit } from "push-it-to-the-limit/target/es5/wrappers/ratelimit";

  declare export { repeat } from "push-it-to-the-limit/target/es5/wrappers/repeat";

  declare export { stabilize } from "push-it-to-the-limit/target/es5/wrappers/stabilize";

  declare export { throttle } from "push-it-to-the-limit/target/es5/wrappers/throttle";
}

declare module "push-it-to-the-limit/target/es5/interface" {
  declare export type IAny = any;
  declare export type IBasicDelay = number;
  declare export type IComplexDelay = {
    period: number,
    count: number,
    ...
  };
  declare export type TimeoutID = $Call<
    <R>((...args: any[]) => R) => R,
    typeof setTimeout
  >;
  declare export type IMixedDelays = Array<IBasicDelay | IComplexDelay>;
  declare export type INormalizedDelays = Array<IComplexDelay>;
  declare export type IDelay = number;
  declare export type ITarget = (...args: IAny[]) => IAny;
  declare export type ILimit = {
    ...IComplexDelay,
    ...{
      ttl: number,
      rest: number,
      timeout?: TimeoutID,
      ...
    },
  };
  declare export type ILimitStack = Array<ILimit>;
  declare export type ICall = {
    fail: () => void,
    complete: () => void,
    ...
  };
  declare export type ICallStack = Array<ICall>;
  declare export type IResolve = (value: IAny) => void;
  declare export type IReject = (value: IAny) => void;
  declare export type IControlled<T = { [key: any]: any, ... }> = {
    ...T,
    ...{
      (...args: IAny[]): Promise<IAny>,
      flush(): void,
      cancel(): void,
      ...
    },
  };
  declare export type ILodashOpts = {
    leading?: boolean,
    trailing?: boolean,
    maxWait?: IBasicDelay,
    ...
  };
  declare export type IOrder = "fifo" | "lifo";
  declare export interface ILimiter {
    limits: ILimitStack;
    getNextDelay(): number;
    reset(): void;
    resetTtl(): void;
    decrease(): void;
    isAllowed(): boolean;
    getNextQueueSize(): number;
  }
  declare export type IWrapperOpts = {
    ...{
      delay: IDelay | IComplexDelay,
      limit?: ILimit | ILimitStack,
      context?: IAny,
      rejectOnCancel?: boolean,
      order?: IOrder,
      limiter?: ILimiter,
      ...
    },
    ...ILodashOpts,
  };
  declare export type IWrapper = (
    fn: ITarget,
    opts: IWrapperOpts
  ) => IControlled<>;
  declare export type IExposedWrapper = {
    (fn: ITarget, opts: IWrapperOpts): IControlled<>,
    (fn: ITarget, delay: IDelay, opts?: ILodashOpts): IControlled<>,
    (fn: ITarget, delay: IComplexDelay, opts?: ILodashOpts): IControlled<>,
    (
      fn: ITarget,
      limit: ILimitStack | ILimit,
      opts?: ILodashOpts
    ): IControlled<>,
    ...
  };
  declare export type Nullable<T> = T | null;
  declare export type NotAlwaysDefined<T> = T | void;
  declare export type Optional<T> = Nullable<T> | NotAlwaysDefined<T>;
}

declare module "push-it-to-the-limit/target/es5/common" {
  import type {
    IAny,
    IBasicDelay,
    IComplexDelay,
    IExposedWrapper,
    ILimit,
    ILimitStack,
    IMixedDelays,
    INormalizedDelays,
    IReject,
    IResolve,
    ITarget,
    IWrapper,
    Optional,
    TimeoutID,
  } from "push-it-to-the-limit/target/es5/interface";

  declare export function complete(
    resolve: IResolve,
    fn: ITarget,
    args: IAny[],
    context?: IAny
  ): void;

  declare export var REJECTED: "Rejected";
  declare export function fail(reject: IReject, message?: string): void;

  declare export var REJECTED_ON_CANCEL: "Rejected on cancel";
  declare export function failOnCancel(reject: IReject): void;

  declare export var DEFAULT_DELAY: 0;
  declare export function adapter(wrapper: IWrapper): IExposedWrapper;

  declare export function assert(condition: boolean, text?: string): void;

  declare export function assertFn(target: IAny): void;

  declare export function dropTimeout(timeout: Optional<TimeoutID>): void;

  declare export function normalizeDelay(
    delay?:
      | IBasicDelay
      | IComplexDelay
      | IMixedDelays
      | INormalizedDelays
      | ILimit
      | ILimitStack
  ): INormalizedDelays;
}

declare module "push-it-to-the-limit/target/es5/limiter" {
  import type {
    IComplexDelay,
    ILimit,
    ILimiter,
    ILimitStack,
  } from "push-it-to-the-limit/target/es5/interface";

  declare export class Limiter mixins ILimiter {
    limits: ILimitStack;
    constructor(items: Array<Limiter | IComplexDelay>): this;
    decrease(): void;
    reset(): void;
    resetTtl(): void;
    isAllowed(): boolean;
    getNextDelay(): number;
    getNextQueueSize(): number;
    static refreshLimit(limit: ILimit): ILimit;
    static refreshTtl(limit: ILimit): void;
  }
}

declare module "push-it-to-the-limit/target/es5/wrappers/debounce" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es5/interface";

  declare export var DEFAULT_OPTS: {
    leading: boolean,
    trailing: boolean,
    ...
  };
  declare export var debounce: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es5/wrappers/delay" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es5/interface";

  declare export var delay: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es5/wrappers/ratelimit" {
  import type {
    ICallStack,
    IExposedWrapper,
    ILimiter,
    TimeoutID,
  } from "push-it-to-the-limit/target/es5/interface";

  declare export type IProcessor = (
    calls: ICallStack,
    limiter: ILimiter
  ) => void;
  declare export var ratelimit: IExposedWrapper;
  declare export function invokeToTheLimit(
    calls: ICallStack,
    limiter: ILimiter
  ): void;

  declare export function refreshTimeouts(
    calls: ICallStack,
    limiter: ILimiter,
    handler: IProcessor
  ): TimeoutID;

  declare export function processTimeouts(
    calls: ICallStack,
    limiter: ILimiter,
    handler: IProcessor
  ): TimeoutID | void;
}

declare module "push-it-to-the-limit/target/es5/wrappers/repeat" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es5/interface";

  declare export var repeat: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es5/wrappers/stabilize" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es5/interface";

  declare export var stabilize: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es5/wrappers/throttle" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es5/interface";

  declare export var throttle: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es6" {
  declare export * from "push-it-to-the-limit/target/es6/interface";

  declare export * from "push-it-to-the-limit/target/es6/common";

  declare export {
    DEFAULT_DELAY,
    REJECTED,
    REJECTED_ON_CANCEL,
  } from "push-it-to-the-limit/target/es6/common";

  declare export { Limiter } from "push-it-to-the-limit/target/es6/limiter";

  declare export { debounce } from "push-it-to-the-limit/target/es6/wrappers/debounce";

  declare export { delay } from "push-it-to-the-limit/target/es6/wrappers/delay";

  declare export { ratelimit } from "push-it-to-the-limit/target/es6/wrappers/ratelimit";

  declare export { repeat } from "push-it-to-the-limit/target/es6/wrappers/repeat";

  declare export { stabilize } from "push-it-to-the-limit/target/es6/wrappers/stabilize";

  declare export { throttle } from "push-it-to-the-limit/target/es6/wrappers/throttle";
}

declare module "push-it-to-the-limit/target/es6/interface" {
  declare export type IAny = any;
  declare export type IBasicDelay = number;
  declare export type IComplexDelay = {
    period: number,
    count: number,
    ...
  };
  declare export type TimeoutID = $Call<
    <R>((...args: any[]) => R) => R,
    typeof setTimeout
  >;
  declare export type IMixedDelays = Array<IBasicDelay | IComplexDelay>;
  declare export type INormalizedDelays = Array<IComplexDelay>;
  declare export type IDelay = number;
  declare export type ITarget = (...args: IAny[]) => IAny;
  declare export type ILimit = {
    ...IComplexDelay,
    ...{
      ttl: number,
      rest: number,
      timeout?: TimeoutID,
      ...
    },
  };
  declare export type ILimitStack = Array<ILimit>;
  declare export type ICall = {
    fail: () => void,
    complete: () => void,
    ...
  };
  declare export type ICallStack = Array<ICall>;
  declare export type IResolve = (value: IAny) => void;
  declare export type IReject = (value: IAny) => void;
  declare export type IControlled<T = { [key: any]: any, ... }> = {
    ...T,
    ...{
      (...args: IAny[]): Promise<IAny>,
      flush(): void,
      cancel(): void,
      ...
    },
  };
  declare export type ILodashOpts = {
    leading?: boolean,
    trailing?: boolean,
    maxWait?: IBasicDelay,
    ...
  };
  declare export type IOrder = "fifo" | "lifo";
  declare export interface ILimiter {
    limits: ILimitStack;
    getNextDelay(): number;
    reset(): void;
    resetTtl(): void;
    decrease(): void;
    isAllowed(): boolean;
    getNextQueueSize(): number;
  }
  declare export type IWrapperOpts = {
    ...{
      delay: IDelay | IComplexDelay,
      limit?: ILimit | ILimitStack,
      context?: IAny,
      rejectOnCancel?: boolean,
      order?: IOrder,
      limiter?: ILimiter,
      ...
    },
    ...ILodashOpts,
  };
  declare export type IWrapper = (
    fn: ITarget,
    opts: IWrapperOpts
  ) => IControlled<>;
  declare export type IExposedWrapper = {
    (fn: ITarget, opts: IWrapperOpts): IControlled<>,
    (fn: ITarget, delay: IDelay, opts?: ILodashOpts): IControlled<>,
    (fn: ITarget, delay: IComplexDelay, opts?: ILodashOpts): IControlled<>,
    (
      fn: ITarget,
      limit: ILimitStack | ILimit,
      opts?: ILodashOpts
    ): IControlled<>,
    ...
  };
  declare export type Nullable<T> = T | null;
  declare export type NotAlwaysDefined<T> = T | void;
  declare export type Optional<T> = Nullable<T> | NotAlwaysDefined<T>;
}

declare module "push-it-to-the-limit/target/es6/common" {
  import type {
    IAny,
    IBasicDelay,
    IComplexDelay,
    IExposedWrapper,
    ILimit,
    ILimitStack,
    IMixedDelays,
    INormalizedDelays,
    IReject,
    IResolve,
    ITarget,
    IWrapper,
    Optional,
    TimeoutID,
  } from "push-it-to-the-limit/target/es6/interface";

  declare export function complete(
    resolve: IResolve,
    fn: ITarget,
    args: IAny[],
    context?: IAny
  ): void;

  declare export var REJECTED: "Rejected";
  declare export function fail(reject: IReject, message?: string): void;

  declare export var REJECTED_ON_CANCEL: "Rejected on cancel";
  declare export function failOnCancel(reject: IReject): void;

  declare export var DEFAULT_DELAY: 0;
  declare export function adapter(wrapper: IWrapper): IExposedWrapper;

  declare export function assert(condition: boolean, text?: string): void;

  declare export function assertFn(target: IAny): void;

  declare export function dropTimeout(timeout: Optional<TimeoutID>): void;

  declare export function normalizeDelay(
    delay?:
      | IBasicDelay
      | IComplexDelay
      | IMixedDelays
      | INormalizedDelays
      | ILimit
      | ILimitStack
  ): INormalizedDelays;
}

declare module "push-it-to-the-limit/target/es6/limiter" {
  import type {
    IComplexDelay,
    ILimit,
    ILimiter,
    ILimitStack,
  } from "push-it-to-the-limit/target/es6/interface";

  declare export class Limiter mixins ILimiter {
    limits: ILimitStack;
    constructor(items: Array<Limiter | IComplexDelay>): this;
    decrease(): void;
    reset(): void;
    resetTtl(): void;
    isAllowed(): boolean;
    getNextDelay(): number;
    getNextQueueSize(): number;
    static refreshLimit(limit: ILimit): ILimit;
    static refreshTtl(limit: ILimit): void;
  }
}

declare module "push-it-to-the-limit/target/es6/wrappers/debounce" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es6/interface";

  declare export var DEFAULT_OPTS: {
    leading: boolean,
    trailing: boolean,
    ...
  };
  declare export var debounce: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es6/wrappers/delay" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es6/interface";

  declare export var delay: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es6/wrappers/ratelimit" {
  import type {
    ICallStack,
    IExposedWrapper,
    ILimiter,
    TimeoutID,
  } from "push-it-to-the-limit/target/es6/interface";

  declare export type IProcessor = (
    calls: ICallStack,
    limiter: ILimiter
  ) => void;
  declare export var ratelimit: IExposedWrapper;
  declare export function invokeToTheLimit(
    calls: ICallStack,
    limiter: ILimiter
  ): void;

  declare export function refreshTimeouts(
    calls: ICallStack,
    limiter: ILimiter,
    handler: IProcessor
  ): TimeoutID;

  declare export function processTimeouts(
    calls: ICallStack,
    limiter: ILimiter,
    handler: IProcessor
  ): TimeoutID | void;
}

declare module "push-it-to-the-limit/target/es6/wrappers/repeat" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es6/interface";

  declare export var repeat: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es6/wrappers/stabilize" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es6/interface";

  declare export var stabilize: IExposedWrapper;
}

declare module "push-it-to-the-limit/target/es6/wrappers/throttle" {
  import type { IExposedWrapper } from "push-it-to-the-limit/target/es6/interface";

  declare export var throttle: IExposedWrapper;
}
