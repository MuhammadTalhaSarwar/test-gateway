export class Limiter {
    constructor(items) {
        this.limits = items.reduce((acc, item) => {
            if (item instanceof Limiter) {
                return acc.concat(item.limits);
            }
            return [...acc, Object.assign(Object.assign({}, item), { rest: item.count, ttl: 0 })];
        }, []);
        return this;
    }
    decrease() {
        this.limits.forEach(limit => {
            limit.rest += -1;
        });
    }
    reset() {
        this.limits.forEach(Limiter.refreshLimit);
    }
    resetTtl() {
        this.limits.forEach(Limiter.refreshTtl);
    }
    isAllowed() {
        return !this.limits.some(({ rest }) => rest < 1);
    }
    getNextDelay() {
        let ttl = 0;
        const limits = this.limits;
        for (const limit of limits) {
            if (limit.rest < 1 && limit.ttl > ttl) {
                ttl = limit.ttl;
            }
        }
        return ttl - Date.now();
    }
    getNextQueueSize() {
        return Math.min(...this.limits.map(({ rest }) => rest));
    }
    static refreshLimit(limit) {
        if (limit.ttl === undefined || limit.ttl < Date.now()) {
            limit.rest = limit.count;
            limit.ttl = Date.now() + limit.period;
        }
        return limit;
    }
    static refreshTtl(limit) {
        limit.ttl = Date.now() + limit.period;
    }
}
