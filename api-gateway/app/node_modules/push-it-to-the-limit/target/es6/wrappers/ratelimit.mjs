import { adapter, complete, dropTimeout, failOnCancel, normalizeDelay } from '../common.mjs';
import { Limiter } from '../limiter.mjs';
export const ratelimit = adapter((fn, opts) => {
    let timeout;
    const { delay, limit, context, rejectOnCancel, limiter } = opts;
    const _limiter = limiter || new Limiter(normalizeDelay(limit || delay));
    const calls = [];
    const processCalls = (calls, limiter) => {
        dropTimeout(timeout);
        limiter.reset();
        invokeToTheLimit(calls, limiter);
        timeout = processTimeouts(calls, limiter, processCalls);
    };
    const res = (...args) => new Promise((resolve, reject) => {
        calls.push({
            complete: complete.bind(undefined, resolve, fn, args, context),
            fail: failOnCancel.bind(undefined, reject)
        });
        processCalls(calls, _limiter);
    });
    res.flush = () => {
        calls.forEach(call => call.complete());
        res.cancel();
    };
    res.cancel = () => {
        if (rejectOnCancel) {
            calls.forEach(call => call.fail());
        }
        calls.length = 0;
        dropTimeout(timeout);
    };
    return res;
});
export function invokeToTheLimit(calls, limiter) {
    var _a;
    while (calls.length > 0 && limiter.isAllowed()) {
        limiter.decrease();
        (_a = calls.shift()) === null || _a === void 0 ? void 0 : _a.complete();
    }
}
export function refreshTimeouts(calls, limiter, handler) {
    return setTimeout(() => handler(calls, limiter), limiter.getNextDelay());
}
export function processTimeouts(calls, limiter, handler) {
    return calls.length > 0
        ? refreshTimeouts(calls, limiter, handler)
        : undefined;
}
