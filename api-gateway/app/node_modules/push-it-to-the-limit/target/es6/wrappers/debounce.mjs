import { adapter, complete, dropTimeout, failOnCancel, normalizeDelay } from '../common.mjs';
import { Limiter } from '../limiter.mjs';
export const DEFAULT_OPTS = {
    leading: false,
    trailing: true
};
export const debounce = adapter((fn, opts) => {
    const { delay, limit, context, rejectOnCancel, maxWait, leading, order, limiter: _limiter } = Object.assign(Object.assign({}, DEFAULT_OPTS), opts);
    const limiter = _limiter || new Limiter(normalizeDelay(limit || delay));
    const args = [];
    const calls = [];
    const completeCalls = () => {
        calls.forEach(call => call.complete());
        calls.length = 0;
    };
    let timeout;
    let maxTimeout;
    let promise;
    let queueLimit;
    const res = (..._args) => {
        dropTimeout(timeout);
        args.push(_args);
        if (queueLimit === undefined) {
            limiter.reset();
            queueLimit = limiter.getNextQueueSize();
        }
        // NOTE `leading` option has priority
        const shouldRun = leading && queueLimit > 0;
        if (queueLimit > 0 || promise === undefined) {
            limiter.decrease();
            queueLimit -= 1;
            promise = new Promise((resolve, reject) => {
                calls.push({
                    complete: () => complete(resolve, fn, order === 'fifo' ? args.shift() : args.pop(), context),
                    fail: failOnCancel.bind(undefined, reject)
                });
            });
        }
        limiter.resetTtl();
        timeout = setTimeout(res.flush, limiter.getNextDelay());
        if (shouldRun) {
            const _p = promise;
            promise = undefined;
            completeCalls();
            return _p;
        }
        if (maxWait && !maxTimeout) {
            maxTimeout = setTimeout(res.flush, maxWait);
        }
        return promise;
    };
    res.flush = () => {
        limiter.reset();
        promise = undefined;
        queueLimit = undefined;
        completeCalls();
        res.cancel();
    };
    res.cancel = () => {
        dropTimeout(timeout);
        dropTimeout(maxTimeout);
        queueLimit = undefined;
        promise = undefined;
        timeout = undefined;
        maxTimeout = undefined;
        args.length = 0;
        if (rejectOnCancel) {
            calls.forEach(call => call.fail());
        }
        calls.length = 0;
    };
    return res;
});
