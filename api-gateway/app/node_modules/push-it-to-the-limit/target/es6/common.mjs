export function complete(resolve, fn, args, context) {
    resolve(fn.call(context, ...args));
}
export const REJECTED = 'Rejected';
export function fail(reject, message = REJECTED) {
    reject(new Error(message));
}
export const REJECTED_ON_CANCEL = 'Rejected on cancel';
export function failOnCancel(reject) {
    fail(reject, REJECTED_ON_CANCEL);
}
export const DEFAULT_DELAY = 0;
const normalizeOpts = (opts = {}) => (Object.assign({ delay: DEFAULT_DELAY }, opts));
// Lodash compatibility wrapper
export function adapter(wrapper) {
    return (fn, value, lodashOpts) => {
        assertFn(fn);
        let opts = normalizeOpts(lodashOpts);
        if (typeof value === 'number') {
            opts = Object.assign(Object.assign({}, opts), { delay: value });
        }
        else if (Array.isArray(value)) {
            opts = Object.assign(Object.assign({}, opts), { limit: value });
        }
        else if (typeof value === 'object') {
            opts = typeof value.period === 'number' && typeof value.count === 'number'
                ? Object.assign(Object.assign({}, opts), { delay: value }) : Object.assign(Object.assign({}, opts), value);
        }
        return wrapper(fn, opts);
    };
}
export function assert(condition, text = 'Assertion error') {
    if (!condition) {
        throw new Error(text);
    }
}
export function assertFn(target) {
    assert(typeof target === 'function', 'Target must be a function');
}
export function dropTimeout(timeout) {
    if (timeout) {
        clearTimeout(timeout);
    }
}
export function normalizeDelay(delay) {
    if (delay === undefined) {
        return [];
    }
    const res = Array.isArray(delay) ? delay : [delay];
    return res
        .map((v) => typeof v === 'number'
        ? { period: v, count: 1 }
        : v);
}
