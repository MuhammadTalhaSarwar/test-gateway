/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.14.1
 */

declare module "inside-out-promise" {
  declare export * from "inside-out-promise/target/es5"
}

declare module "inside-out-promise/target/es5" {
  import type {
    TInsideOutPromise,
    TPromiseExecutor,
    IPromiseFactory,
    TPromiseState,
    TPromiseFactoryOpts,
    TNormalizedPromiseFactoryOpts,
  } from "inside-out-promise/target/es5/interface";

  declare export * from "inside-out-promise/target/es5/interface"

  declare export var factory: IPromiseFactory;
  declare export class InsideOutPromise<TValue, TReason>
    mixins TInsideOutPromise<TValue, TReason> {
    state: $Values<typeof TPromiseState>;
    value: any;
    reason: any;
    constructor(
      executor?: TPromiseExecutor<TValue, TReason> | TPromiseFactoryOpts,
      opts?: TPromiseFactoryOpts
    ): this;
    promise: InsideOutPromise<TValue, TReason>;
    status: $Values<typeof TPromiseState>;
    result: any;
    resolve(value?: any): InsideOutPromise<TValue, TReason>;
    reject(reason?: any): InsideOutPromise<TValue, TReason>;
    then(
      onSuccess?: (value: TValue) => any,
      onReject?: (reason: any) => any
    ): InsideOutPromise<TValue, TReason>;
    catch(onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
    finally(handler?: () => any): InsideOutPromise<TValue, TReason>;
    isPending(): boolean;
    isFulfilled(): boolean;
    isRejected(): boolean;
    isResolved(): boolean;
    [typeof Symbol.toStringTag]: string;
    [typeof Symbol.species]: any;
    [typeof Symbol.species]: any;
    [typeof Symbol.toStringTag]: string;
    static normalizeOpts(
      executor?: TPromiseExecutor | TPromiseFactoryOpts,
      opts?: TPromiseFactoryOpts
    ): TNormalizedPromiseFactoryOpts;
    static Promise: PromiseConstructor;
  }
}

declare module "inside-out-promise/target/es5/interface" {
  import type { IPromise, IPromiseConstructor } from "@qiwi/substrate";

  declare export type TPromiseExecutor<TValue = any, TReason = any> = (
    resolve: (value: TValue) => void,
    reject: (reason: TReason) => void
  ) => void;
  /* 
    declare module '@qiwi/substrate' {
      declare interface IPromiseConstructor<TValue= any, TReason= any> {
+[typeof Symbol.species]: any,
new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>,
all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>,
allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>,
any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
reject: (reason?: TReason) => IPromise<TValue, TReason>,
resolve: (value?: TValue) => IPromise<TValue, TReason>,
+[typeof Symbol.species]: any,
new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>,
all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>,
allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>,
any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
reject: (reason?: TReason) => IPromise<TValue, TReason>,
resolve: (value?: TValue) => IPromise<TValue, TReason>,
} 
    }
     */

  declare export var TPromiseState: {|
    +PENDING: "Pending", // "Pending"
    +FULFILLED: "Fulfilled", // "Fulfilled"
    +REJECTED: "Rejected", // "Rejected"
  |};

  declare export type TInsideOutPromise<TValue = any, TReason = any> = {
    promise: TInsideOutPromise<TValue, TReason>,
    resolve: (value?: TReason) => TInsideOutPromise<TValue, TReason>,
    reject: (reason?: TReason) => TInsideOutPromise<TValue, TReason>,
    then: (
      onSuccess?: (value: TValue) => any,
      onReject?: (reason: any) => any
    ) => TInsideOutPromise<TValue, TReason>,
    catch: (
      onReject: (reason: any) => any
    ) => TInsideOutPromise<TValue, TReason>,
    finally: (handler?: () => any) => TInsideOutPromise<TValue, TReason>,
    +[typeof Symbol.toStringTag]: string,
    +[typeof Symbol.species]: any,
    state: $Values<typeof TPromiseState>,
    status: $Values<typeof TPromiseState>,
    result: any,
    value: any,
    reason: any,
    isRejected: () => boolean,
    isFulfilled: () => boolean,
    isPending: () => boolean,
    isResolved: () => boolean,
    ...
  } & IPromise<TValue, TReason>;

  declare export { IPromise, IPromiseConstructor };

  declare export type TPromiseFactoryOpts = {
    executor?: TPromiseExecutor<>,
    Promise?: any,
    ...
  };
  declare export type TNormalizedPromiseFactoryOpts = {
    executor: TPromiseExecutor<>,
    Promise: any,
    ...
  };
  declare export interface IPromiseFactory {
    (
      executor?: TPromiseExecutor<>,
      opts?: TPromiseFactoryOpts
    ): TInsideOutPromise<>;
    (opts?: TPromiseFactoryOpts): TInsideOutPromise<>;
    Promise?: any;
  }
}

declare module "inside-out-promise/target/es6" {
  import type {
    TInsideOutPromise,
    TPromiseExecutor,
    IPromiseFactory,
    TPromiseState,
    TPromiseFactoryOpts,
    TNormalizedPromiseFactoryOpts,
  } from "inside-out-promise/target/es6/interface";

  declare export * from "inside-out-promise/target/es6/interface"

  declare export var factory: IPromiseFactory;
  declare export class InsideOutPromise<TValue, TReason>
    mixins TInsideOutPromise<TValue, TReason> {
    state: $Values<typeof TPromiseState>;
    value: any;
    reason: any;
    constructor(
      executor?: TPromiseExecutor<TValue, TReason> | TPromiseFactoryOpts,
      opts?: TPromiseFactoryOpts
    ): this;
    promise: InsideOutPromise<TValue, TReason>;
    status: $Values<typeof TPromiseState>;
    result: any;
    resolve(value?: any): InsideOutPromise<TValue, TReason>;
    reject(reason?: any): InsideOutPromise<TValue, TReason>;
    then(
      onSuccess?: (value: TValue) => any,
      onReject?: (reason: any) => any
    ): InsideOutPromise<TValue, TReason>;
    catch(onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
    finally(handler?: () => any): InsideOutPromise<TValue, TReason>;
    isPending(): boolean;
    isFulfilled(): boolean;
    isRejected(): boolean;
    isResolved(): boolean;
    [typeof Symbol.toStringTag]: string;
    [typeof Symbol.species]: any;
    [typeof Symbol.species]: any;
    [typeof Symbol.toStringTag]: string;
    static normalizeOpts(
      executor?: TPromiseExecutor | TPromiseFactoryOpts,
      opts?: TPromiseFactoryOpts
    ): TNormalizedPromiseFactoryOpts;
    static Promise: PromiseConstructor;
  }
}

declare module "inside-out-promise/target/es6/interface" {
  import type { IPromise, IPromiseConstructor } from "@qiwi/substrate";

  declare export type TPromiseExecutor<TValue = any, TReason = any> = (
    resolve: (value: TValue) => void,
    reject: (reason: TReason) => void
  ) => void;
  /* 
    declare module '@qiwi/substrate' {
      declare interface IPromiseConstructor<TValue= any, TReason= any> {
+[typeof Symbol.species]: any,
new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>,
all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>,
allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>,
any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
reject: (reason?: TReason) => IPromise<TValue, TReason>,
resolve: (value?: TValue) => IPromise<TValue, TReason>,
+[typeof Symbol.species]: any,
new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>,
all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>,
allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>,
any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>,
reject: (reason?: TReason) => IPromise<TValue, TReason>,
resolve: (value?: TValue) => IPromise<TValue, TReason>,
} 
    }
     */

  declare export var TPromiseState: {|
    +PENDING: "Pending", // "Pending"
    +FULFILLED: "Fulfilled", // "Fulfilled"
    +REJECTED: "Rejected", // "Rejected"
  |};

  declare export type TInsideOutPromise<TValue = any, TReason = any> = {
    promise: TInsideOutPromise<TValue, TReason>,
    resolve: (value?: TReason) => TInsideOutPromise<TValue, TReason>,
    reject: (reason?: TReason) => TInsideOutPromise<TValue, TReason>,
    then: (
      onSuccess?: (value: TValue) => any,
      onReject?: (reason: any) => any
    ) => TInsideOutPromise<TValue, TReason>,
    catch: (
      onReject: (reason: any) => any
    ) => TInsideOutPromise<TValue, TReason>,
    finally: (handler?: () => any) => TInsideOutPromise<TValue, TReason>,
    +[typeof Symbol.toStringTag]: string,
    +[typeof Symbol.species]: any,
    state: $Values<typeof TPromiseState>,
    status: $Values<typeof TPromiseState>,
    result: any,
    value: any,
    reason: any,
    isRejected: () => boolean,
    isFulfilled: () => boolean,
    isPending: () => boolean,
    isResolved: () => boolean,
    ...
  } & IPromise<TValue, TReason>;

  declare export { IPromise, IPromiseConstructor };

  declare export type TPromiseFactoryOpts = {
    executor?: TPromiseExecutor<>,
    Promise?: any,
    ...
  };
  declare export type TNormalizedPromiseFactoryOpts = {
    executor: TPromiseExecutor<>,
    Promise: any,
    ...
  };
  declare export interface IPromiseFactory {
    (
      executor?: TPromiseExecutor<>,
      opts?: TPromiseFactoryOpts
    ): TInsideOutPromise<>;
    (opts?: TPromiseFactoryOpts): TInsideOutPromise<>;
    Promise?: any;
  }
}
