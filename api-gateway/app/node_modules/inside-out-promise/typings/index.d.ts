declare module 'inside-out-promise' {
  /** */
  export * from 'inside-out-promise/target/es5';
}
// Generated by dts-bundle v0.7.5
// Dependencies for this module:
//   interface.d.ts

declare module 'inside-out-promise/target/es5' {
    import { TInsideOutPromise, TPromiseExecutor, IPromiseFactory, TPromiseState, TPromiseFactoryOpts, TNormalizedPromiseFactoryOpts } from 'inside-out-promise/target/es5/interface';
    export * from 'inside-out-promise/target/es5/interface';
    export const factory: IPromiseFactory;
    export class InsideOutPromise<TValue, TReason> implements TInsideOutPromise<TValue, TReason> {
        state: TPromiseState;
        value: any;
        reason: any;
        constructor(executor?: TPromiseExecutor<TValue, TReason> | TPromiseFactoryOpts, opts?: TPromiseFactoryOpts);
        get promise(): InsideOutPromise<TValue, TReason>;
        get status(): TPromiseState;
        get result(): any;
        resolve(value?: any): InsideOutPromise<TValue, TReason>;
        reject(reason?: any): InsideOutPromise<TValue, TReason>;
        then(onSuccess?: (value: TValue) => any, onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
        catch(onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
        finally(handler?: () => any): InsideOutPromise<TValue, TReason>;
        isPending(): boolean;
        isFulfilled(): boolean;
        isRejected(): boolean;
        isResolved(): boolean;
        get [Symbol.toStringTag](): string;
        get [Symbol.species](): any;
        static get [Symbol.species](): any;
        static get [Symbol.toStringTag](): string;
        static normalizeOpts(executor?: TPromiseExecutor | TPromiseFactoryOpts, opts?: TPromiseFactoryOpts): TNormalizedPromiseFactoryOpts;
        static Promise: PromiseConstructor;
    }
}

declare module 'inside-out-promise/target/es5/interface' {
    import { IPromise, IPromiseConstructor } from '@qiwi/substrate';
    export type TPromiseExecutor<TValue = any, TReason = any> = (resolve: (value: TValue) => void, reject: (reason: TReason) => void) => void;
    module '@qiwi/substrate' {
        interface IPromiseConstructor<TValue = any, TReason = any> {
            readonly [Symbol.species]: any;
            new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>;
            all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>;
            allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>;
            any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>;
            race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>;
            reject: (reason?: TReason) => IPromise<TValue, TReason>;
            resolve: (value?: TValue) => IPromise<TValue, TReason>;
        }
    }
    export enum TPromiseState {
        PENDING = "Pending",
        FULFILLED = "Fulfilled",
        REJECTED = "Rejected"
    }
    export interface TInsideOutPromise<TValue = any, TReason = any> extends IPromise<TValue, TReason> {
        promise: TInsideOutPromise<TValue, TReason>;
        resolve: (value?: TReason) => TInsideOutPromise<TValue, TReason>;
        reject: (reason?: TReason) => TInsideOutPromise<TValue, TReason>;
        then: (onSuccess?: (value: TValue) => any, onReject?: (reason: any) => any) => TInsideOutPromise<TValue, TReason>;
        catch: (onReject: (reason: any) => any) => TInsideOutPromise<TValue, TReason>;
        finally: (handler?: () => any) => TInsideOutPromise<TValue, TReason>;
        readonly [Symbol.toStringTag]: string;
        readonly [Symbol.species]: any;
        state: TPromiseState;
        status: TPromiseState;
        result: any;
        value: any;
        reason: any;
        isRejected: () => boolean;
        isFulfilled: () => boolean;
        isPending: () => boolean;
        isResolved: () => boolean;
    }
    export { IPromise, IPromiseConstructor, };
    export type TPromiseFactoryOpts = {
        executor?: TPromiseExecutor;
        Promise?: any;
    };
    export type TNormalizedPromiseFactoryOpts = {
        executor: TPromiseExecutor;
        Promise: any;
    };
    export interface IPromiseFactory {
        (executor?: TPromiseExecutor, opts?: TPromiseFactoryOpts): TInsideOutPromise;
        (opts?: TPromiseFactoryOpts): TInsideOutPromise;
        Promise?: any;
    }
}

// Generated by dts-bundle v0.7.5
// Dependencies for this module:
//   interface.d.ts

declare module 'inside-out-promise/target/es6' {
    import { TInsideOutPromise, TPromiseExecutor, IPromiseFactory, TPromiseState, TPromiseFactoryOpts, TNormalizedPromiseFactoryOpts } from 'inside-out-promise/target/es6/interface';
    export * from 'inside-out-promise/target/es6/interface';
    export const factory: IPromiseFactory;
    export class InsideOutPromise<TValue, TReason> implements TInsideOutPromise<TValue, TReason> {
        state: TPromiseState;
        value: any;
        reason: any;
        constructor(executor?: TPromiseExecutor<TValue, TReason> | TPromiseFactoryOpts, opts?: TPromiseFactoryOpts);
        get promise(): InsideOutPromise<TValue, TReason>;
        get status(): TPromiseState;
        get result(): any;
        resolve(value?: any): InsideOutPromise<TValue, TReason>;
        reject(reason?: any): InsideOutPromise<TValue, TReason>;
        then(onSuccess?: (value: TValue) => any, onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
        catch(onReject?: (reason: any) => any): InsideOutPromise<TValue, TReason>;
        finally(handler?: () => any): InsideOutPromise<TValue, TReason>;
        isPending(): boolean;
        isFulfilled(): boolean;
        isRejected(): boolean;
        isResolved(): boolean;
        get [Symbol.toStringTag](): string;
        get [Symbol.species](): any;
        static get [Symbol.species](): any;
        static get [Symbol.toStringTag](): string;
        static normalizeOpts(executor?: TPromiseExecutor | TPromiseFactoryOpts, opts?: TPromiseFactoryOpts): TNormalizedPromiseFactoryOpts;
        static Promise: PromiseConstructor;
    }
}

declare module 'inside-out-promise/target/es6/interface' {
    import { IPromise, IPromiseConstructor } from '@qiwi/substrate';
    export type TPromiseExecutor<TValue = any, TReason = any> = (resolve: (value: TValue) => void, reject: (reason: TReason) => void) => void;
    module '@qiwi/substrate' {
        interface IPromiseConstructor<TValue = any, TReason = any> {
            readonly [Symbol.species]: any;
            new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>;
            all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>;
            allSettled: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<any>;
            any: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>;
            race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>;
            reject: (reason?: TReason) => IPromise<TValue, TReason>;
            resolve: (value?: TValue) => IPromise<TValue, TReason>;
        }
    }
    export enum TPromiseState {
        PENDING = "Pending",
        FULFILLED = "Fulfilled",
        REJECTED = "Rejected"
    }
    export interface TInsideOutPromise<TValue = any, TReason = any> extends IPromise<TValue, TReason> {
        promise: TInsideOutPromise<TValue, TReason>;
        resolve: (value?: TReason) => TInsideOutPromise<TValue, TReason>;
        reject: (reason?: TReason) => TInsideOutPromise<TValue, TReason>;
        then: (onSuccess?: (value: TValue) => any, onReject?: (reason: any) => any) => TInsideOutPromise<TValue, TReason>;
        catch: (onReject: (reason: any) => any) => TInsideOutPromise<TValue, TReason>;
        finally: (handler?: () => any) => TInsideOutPromise<TValue, TReason>;
        readonly [Symbol.toStringTag]: string;
        readonly [Symbol.species]: any;
        state: TPromiseState;
        status: TPromiseState;
        result: any;
        value: any;
        reason: any;
        isRejected: () => boolean;
        isFulfilled: () => boolean;
        isPending: () => boolean;
        isResolved: () => boolean;
    }
    export { IPromise, IPromiseConstructor, };
    export type TPromiseFactoryOpts = {
        executor?: TPromiseExecutor;
        Promise?: any;
    };
    export type TNormalizedPromiseFactoryOpts = {
        executor: TPromiseExecutor;
        Promise: any;
    };
    export interface IPromiseFactory {
        (executor?: TPromiseExecutor, opts?: TPromiseFactoryOpts): TInsideOutPromise;
        (opts?: TPromiseFactoryOpts): TInsideOutPromise;
        Promise?: any;
    }
}

