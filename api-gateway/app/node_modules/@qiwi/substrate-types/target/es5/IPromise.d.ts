import { IConstructor } from './IConstructor';
export type TPromiseExecutor<TValue = any, TReason = any> = (resolve: (value: TValue) => void, reject: (reason: TReason) => void) => void;
export interface IPromise<TValue = any, TReason = any> {
    then: (onSuccess?: (value: TValue) => any, onReject?: (reason: TReason) => any) => IPromise;
    catch: (onReject: (reason: TReason) => any) => IPromise;
    finally: (onFinally: () => any) => IPromise;
    readonly [Symbol.toStringTag]: string;
}
export interface IPromiseConstructor<TValue = any, TReason = any> extends IConstructor<IPromise<TValue, TReason>> {
    new (executor: TPromiseExecutor<TValue>): IPromise<TValue, TReason>;
    all: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue[], TReason>;
    race: (values: Iterable<IPromise<TValue, TReason>>) => IPromise<TValue, TReason>;
    reject: (reason?: TReason) => IPromise<TValue, TReason>;
    resolve: (value?: TValue) => IPromise<TValue, TReason>;
}
export declare const IPromise: PromiseConstructor;
