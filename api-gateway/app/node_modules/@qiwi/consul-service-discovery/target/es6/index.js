"use strict";
/** @module @qiwi/consul-service-discovery */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsulDiscoveryService = void 0;
const tslib_1 = require("tslib");
const consulUtils_1 = require("./consulUtils");
const cxt_1 = require("./cxt");
const defaults_1 = require("./defaults");
const util_1 = require("./util");
tslib_1.__exportStar(require("./interface"), exports);
tslib_1.__exportStar(require("./defaults"), exports);
/**
 * @class ConsulDiscoveryService
 */
class ConsulDiscoveryService {
    constructor({ host, port, secure, defaults, ca }, cxt = {}) {
        this.services = {
            discovery: {},
            kv: {}
        };
        this.cxt = (0, cxt_1.createContext)(cxt);
        this._consul = this.cxt.Consul({
            secure,
            host,
            port: port === null || port === void 0 ? void 0 : port.toString(),
            defaults,
            ca
        });
    }
    getKv(key) {
        return this.ready(key, 'kv').then(({ data }) => data);
    }
    setKv(data) {
        return new Promise((resolve, reject) => {
            this._consul.kv.set(data, (err, res) => {
                if (err) {
                    reject(err);
                }
                resolve(res);
            });
        });
    }
    ready(serviceName, type) {
        const service = this.getService(serviceName, type);
        if (service.iop) {
            // @ts-ignore
            return service.iop.promise;
        }
        service.iop = (0, util_1.promiseFactory)();
        this.cxt.logger.debug(`watcher initialized, service=${serviceName}`);
        consulUtils_1.ConsulUtils.watchOnError(service, this.services[type], this.cxt.logger);
        consulUtils_1.ConsulUtils.watchOnChange(service, this.services[type], this.cxt.logger);
        return service.iop.promise;
    }
    getService(serviceName, type) {
        return this.services[type][serviceName] || this.createService(serviceName, type);
    }
    createService(serviceName, type) {
        const watcher = this.getWatcher(serviceName, type);
        const service = type === 'kv' ? {
            type,
            name: serviceName,
            watcher,
            data: {},
            sequentialErrorCount: 0
        } : {
            type,
            name: serviceName,
            watcher,
            data: [],
            sequentialErrorCount: 0
        };
        this.services[type][serviceName] = service;
        return service;
    }
    /**
     * Gets all service connections.
     * @param {string} serviceName
     * @return {Array<IConnectionParams>}
     */
    getConnections(serviceName) {
        return this.ready(serviceName, 'discovery').then(({ data }) => data);
    }
    /**
     * Gets random service connection.
     * @param {string} serviceName
     * @returns {IConnectionParams | undefined}
     */
    getConnection(serviceName) {
        return this.getConnections(serviceName).then(util_1.sample);
    }
    /**
     * @deprecated
     * @param {string} serviceName
     * @returns {IConnectionParams | undefined}
     */
    getConnectionParams(serviceName) {
        return this.getConnection(serviceName);
    }
    getWatcher(serviceName, type) {
        const method = type === 'kv' ? this._consul.kv.get : this._consul.health.service;
        const options = type === 'kv'
            ? {
                key: serviceName
            }
            : {
                service: serviceName,
                passing: true
            };
        return this._consul.watch({
            method,
            options,
            backoffMax: defaults_1.BACKOFF_MAX
        });
    }
    register(opts, registerCheckInterval) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const reg = this._register.bind(this);
            if (registerCheckInterval) {
                if (this._repeatableRegister) {
                    this._repeatableRegister.cancel();
                }
                this._repeatableRegister = (0, util_1.repeat)(reg, registerCheckInterval);
            }
            const register = this._repeatableRegister || reg;
            return register(opts);
        });
    }
    _register(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = this._id ||
                consulUtils_1.ConsulUtils.generateId({
                    serviceName: opts.name,
                    remoteAddress: opts.address,
                    port: opts.port
                });
            this._id = id;
            const _opts = Object.assign({ id }, opts);
            if (yield this.find(id)) {
                return Promise.resolve(void 0);
            }
            const agentService = this._consul.agent.service;
            const register = agentService.register.bind(agentService);
            return consulUtils_1.ConsulUtils.promisify(register, _opts)
                .then((data) => {
                this.cxt.logger.info(`service ${id} registered`);
                return data;
            })
                .catch(e => {
                this.cxt.logger.error(`failed to register ${id}`);
                throw e;
            });
        });
    }
    list(token) {
        const opts = token ? { token } : {};
        const agentService = this._consul.agent.service;
        const getList = this._consul.agent.service.list.bind(agentService);
        return consulUtils_1.ConsulUtils.promisify(getList, opts);
    }
    find(id) {
        return this.list()
            .then((res) => res[id])
            .catch((e) => {
            throw new Error(`fail find service: ${e}`);
        });
    }
}
exports.ConsulDiscoveryService = ConsulDiscoveryService;
exports.default = ConsulDiscoveryService;
