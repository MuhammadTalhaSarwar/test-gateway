"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsulUtils = void 0;
const uuid_1 = require("uuid");
const defaults_1 = require("./defaults");
const util_1 = require("./util");
class ConsulUtils {
    static promisify(method, opts) {
        const { resolve, reject, promise } = (0, util_1.promiseFactory)();
        method(opts, (err, data) => {
            if (err) {
                reject.call(promise, err);
                return;
            }
            resolve.call(promise, data);
        });
        return promise;
    }
    static generateId({ serviceName, localAddress = '0.0.0.0', port = '', remoteAddress = '0.0.0.0' }) {
        return `${serviceName}-${remoteAddress}-${localAddress}-${port}-${(0, uuid_1.v4)()}`.replace(/\./g, '-');
    }
    static normalizeKvValue(data) {
        return Object.keys(data).reduce((acc, el) => {
            const key = el[0].toLowerCase() + el.slice(1);
            acc[key] = data[el];
            return acc;
        }, {});
    }
    static normalizeEntryPoint(data) {
        return data.reduce((memo, entryPoint) => {
            const address = entryPoint.Service.Address || entryPoint.Node.Address;
            const port = entryPoint.Service.Port;
            if (address) {
                memo.push({
                    host: address,
                    port
                });
            }
            return memo;
        }, []);
    }
    static handleKvValue(data, services, service, logger) {
        var _a;
        if (data.value) {
            service.sequentialErrorCount = 0;
            service.data = data;
        }
        else {
            logger.warn(`watcher got empty or invalid kv data, service=${service.name}`, 'data=', data);
        }
        if (service.data.value) {
            (_a = service.iop) === null || _a === void 0 ? void 0 : _a.resolve(service);
        }
        else {
            ConsulUtils.handleError(service, new Error('got empty or invalid kv data'), services, logger);
        }
    }
    static handleConnectionParams(data, services, service, logger) {
        var _a;
        if (data.length > 0) {
            service.sequentialErrorCount = 0;
            service.data.length = 0;
            service.data.push(...data);
        }
        else {
            logger.warn(`watcher got empty or invalid connection params, service=${service.name}`, 'data=', data);
        }
        if (service.data.length > 0) {
            (_a = service.iop) === null || _a === void 0 ? void 0 : _a.resolve(service);
        }
        else {
            ConsulUtils.handleError(service, new Error('got empty or invalid connection params'), services, logger);
        }
    }
    static watchOnChange(service, services, logger) {
        if (service.watcher.listenerCount('change')) {
            return;
        }
        service.watcher.on('change', (data) => {
            var _a;
            const normalizedData = Array.isArray(data)
                ? ConsulUtils.normalizeEntryPoint(data)
                : ConsulUtils.normalizeKvValue(data);
            if ((_a = service.iop) === null || _a === void 0 ? void 0 : _a.isFulfilled()) {
                service.iop = (0, util_1.promiseFactory)();
            }
            if (Array.isArray(normalizedData)) {
                //  @ts-ignore
                ConsulUtils.handleConnectionParams(normalizedData, services, service, logger);
            }
            else {
                ConsulUtils.handleKvValue(normalizedData, services, service, logger);
            }
        });
    }
    static watchOnError(service, services, logger) {
        if (service.watcher.listenerCount('error')) {
            return;
        }
        service.watcher.on('error', (err) => ConsulUtils.handleError(service, err, services, logger));
    }
    static handleError(service, err, services, logger) {
        var _a;
        service.sequentialErrorCount += 1;
        logger.error(`watcher error, service=${service.name} type=${service.type}`, 'error=', err);
        logger.info(`sequentialErrorCount=${service.sequentialErrorCount}, service=${service.name} type=${service.type}`);
        (_a = service.iop) === null || _a === void 0 ? void 0 : _a.reject(err);
        delete service.iop;
        // https://github.com/qiwi/consul-service-discovery/issues/81
        // Recreate instance if it hangs
        if (err.isPapi && /request timed out/.test(err.message)) {
            ConsulUtils.clearService(services, service);
            logger.error(`watcher timeout err=${err.message}`);
            return;
        }
        if (service.type === 'discovery' && service.data.length === 0) {
            ConsulUtils.clearService(services, service);
        }
        if (service.type === 'kv' && (service.data.value === undefined || service.data.value === null)) {
            ConsulUtils.clearService(services, service);
        }
        // Once WATCH_ERROR_LIMIT is reached, reset watcher and instances
        if (service.sequentialErrorCount >= defaults_1.WATCH_ERROR_LIMIT) {
            ConsulUtils.clearService(services, service);
            logger.error(`watcher error limit is reached, service=${service.name}`);
        }
    }
    static clearService(services, service) {
        if (services[service.name]) {
            service.watcher.end();
            delete services[service.name];
        }
    }
}
exports.ConsulUtils = ConsulUtils;
