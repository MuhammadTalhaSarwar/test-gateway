"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsulUtils = void 0;
var uuid_1 = require("uuid");
var defaults_1 = require("./defaults");
var util_1 = require("./util");
var ConsulUtils = /** @class */ (function () {
    function ConsulUtils() {
    }
    ConsulUtils.promisify = function (method, opts) {
        var _a = (0, util_1.promiseFactory)(), resolve = _a.resolve, reject = _a.reject, promise = _a.promise;
        method(opts, function (err, data) {
            if (err) {
                reject.call(promise, err);
                return;
            }
            resolve.call(promise, data);
        });
        return promise;
    };
    ConsulUtils.generateId = function (_a) {
        var serviceName = _a.serviceName, _b = _a.localAddress, localAddress = _b === void 0 ? '0.0.0.0' : _b, _c = _a.port, port = _c === void 0 ? '' : _c, _d = _a.remoteAddress, remoteAddress = _d === void 0 ? '0.0.0.0' : _d;
        return "".concat(serviceName, "-").concat(remoteAddress, "-").concat(localAddress, "-").concat(port, "-").concat((0, uuid_1.v4)()).replace(/\./g, '-');
    };
    ConsulUtils.normalizeKvValue = function (data) {
        return Object.keys(data).reduce(function (acc, el) {
            var key = el[0].toLowerCase() + el.slice(1);
            acc[key] = data[el];
            return acc;
        }, {});
    };
    ConsulUtils.normalizeEntryPoint = function (data) {
        return data.reduce(function (memo, entryPoint) {
            var address = entryPoint.Service.Address || entryPoint.Node.Address;
            var port = entryPoint.Service.Port;
            if (address) {
                memo.push({
                    host: address,
                    port: port
                });
            }
            return memo;
        }, []);
    };
    ConsulUtils.handleKvValue = function (data, services, service, logger) {
        var _a;
        if (data.value) {
            service.sequentialErrorCount = 0;
            service.data = data;
        }
        else {
            logger.warn("watcher got empty or invalid kv data, service=".concat(service.name), 'data=', data);
        }
        if (service.data.value) {
            (_a = service.iop) === null || _a === void 0 ? void 0 : _a.resolve(service);
        }
        else {
            ConsulUtils.handleError(service, new Error('got empty or invalid kv data'), services, logger);
        }
    };
    ConsulUtils.handleConnectionParams = function (data, services, service, logger) {
        var _a;
        var _b;
        if (data.length > 0) {
            service.sequentialErrorCount = 0;
            service.data.length = 0;
            (_a = service.data).push.apply(_a, data);
        }
        else {
            logger.warn("watcher got empty or invalid connection params, service=".concat(service.name), 'data=', data);
        }
        if (service.data.length > 0) {
            (_b = service.iop) === null || _b === void 0 ? void 0 : _b.resolve(service);
        }
        else {
            ConsulUtils.handleError(service, new Error('got empty or invalid connection params'), services, logger);
        }
    };
    ConsulUtils.watchOnChange = function (service, services, logger) {
        if (service.watcher.listenerCount('change')) {
            return;
        }
        service.watcher.on('change', function (data) {
            var _a;
            var normalizedData = Array.isArray(data)
                ? ConsulUtils.normalizeEntryPoint(data)
                : ConsulUtils.normalizeKvValue(data);
            if ((_a = service.iop) === null || _a === void 0 ? void 0 : _a.isFulfilled()) {
                service.iop = (0, util_1.promiseFactory)();
            }
            if (Array.isArray(normalizedData)) {
                //  @ts-ignore
                ConsulUtils.handleConnectionParams(normalizedData, services, service, logger);
            }
            else {
                ConsulUtils.handleKvValue(normalizedData, services, service, logger);
            }
        });
    };
    ConsulUtils.watchOnError = function (service, services, logger) {
        if (service.watcher.listenerCount('error')) {
            return;
        }
        service.watcher.on('error', function (err) {
            return ConsulUtils.handleError(service, err, services, logger);
        });
    };
    ConsulUtils.handleError = function (service, err, services, logger) {
        var _a;
        service.sequentialErrorCount += 1;
        logger.error("watcher error, service=".concat(service.name, " type=").concat(service.type), 'error=', err);
        logger.info("sequentialErrorCount=".concat(service.sequentialErrorCount, ", service=").concat(service.name, " type=").concat(service.type));
        (_a = service.iop) === null || _a === void 0 ? void 0 : _a.reject(err);
        delete service.iop;
        // https://github.com/qiwi/consul-service-discovery/issues/81
        // Recreate instance if it hangs
        if (err.isPapi && /request timed out/.test(err.message)) {
            ConsulUtils.clearService(services, service);
            logger.error("watcher timeout err=".concat(err.message));
            return;
        }
        if (service.type === 'discovery' && service.data.length === 0) {
            ConsulUtils.clearService(services, service);
        }
        if (service.type === 'kv' && (service.data.value === undefined || service.data.value === null)) {
            ConsulUtils.clearService(services, service);
        }
        // Once WATCH_ERROR_LIMIT is reached, reset watcher and instances
        if (service.sequentialErrorCount >= defaults_1.WATCH_ERROR_LIMIT) {
            ConsulUtils.clearService(services, service);
            logger.error("watcher error limit is reached, service=".concat(service.name));
        }
    };
    ConsulUtils.clearService = function (services, service) {
        if (services[service.name]) {
            service.watcher.end();
            delete services[service.name];
        }
    };
    return ConsulUtils;
}());
exports.ConsulUtils = ConsulUtils;
